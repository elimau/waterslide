// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: init-config.proto

#include "init-config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr InitConfig_Endpoint::InitConfig_Endpoint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : addr_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , port_(0){}
struct InitConfig_EndpointDefaultTypeInternal {
  constexpr InitConfig_EndpointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitConfig_EndpointDefaultTypeInternal() {}
  union {
    InitConfig_Endpoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitConfig_EndpointDefaultTypeInternal _InitConfig_Endpoint_default_instance_;
constexpr InitConfig_Mux::InitConfig_Mux(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : maxchannels_(0)
  , maxpacketsize_(0){}
struct InitConfig_MuxDefaultTypeInternal {
  constexpr InitConfig_MuxDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitConfig_MuxDefaultTypeInternal() {}
  union {
    InitConfig_Mux _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitConfig_MuxDefaultTypeInternal _InitConfig_Mux_default_instance_;
constexpr InitConfig_Audio::InitConfig_Audio(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : devicename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , channelcount_(0)
  , iosamplerate_(0)
  , levelslowattack_(0)
  , levelslowrelease_(0)
  , levelfastattack_(0)
  , levelfastrelease_(0){}
struct InitConfig_AudioDefaultTypeInternal {
  constexpr InitConfig_AudioDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitConfig_AudioDefaultTypeInternal() {}
  union {
    InitConfig_Audio _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitConfig_AudioDefaultTypeInternal _InitConfig_Audio_default_instance_;
constexpr InitConfig_Opus::InitConfig_Opus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bitrate_(0)
  , framesize_(0)
  , maxpacketsize_(0)
  , samplerate_(0)
  , encoderinglength_(0)
  , decoderinglength_(0){}
struct InitConfig_OpusDefaultTypeInternal {
  constexpr InitConfig_OpusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitConfig_OpusDefaultTypeInternal() {}
  union {
    InitConfig_Opus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitConfig_OpusDefaultTypeInternal _InitConfig_Opus_default_instance_;
constexpr InitConfig_Fec::InitConfig_Fec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : symbollen_(0)
  , sourcesymbolsperblock_(0)
  , repairsymbolsperblock_(0){}
struct InitConfig_FecDefaultTypeInternal {
  constexpr InitConfig_FecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitConfig_FecDefaultTypeInternal() {}
  union {
    InitConfig_Fec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitConfig_FecDefaultTypeInternal _InitConfig_Fec_default_instance_;
constexpr InitConfig_Monitor::InitConfig_Monitor(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : wsport_(0){}
struct InitConfig_MonitorDefaultTypeInternal {
  constexpr InitConfig_MonitorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitConfig_MonitorDefaultTypeInternal() {}
  union {
    InitConfig_Monitor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitConfig_MonitorDefaultTypeInternal _InitConfig_Monitor_default_instance_;
constexpr InitConfig::InitConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endpoints_()
  , mux_(nullptr)
  , audio_(nullptr)
  , opus_(nullptr)
  , fec_(nullptr)
  , monitor_(nullptr)
  , mode_(0)
{}
struct InitConfigDefaultTypeInternal {
  constexpr InitConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitConfigDefaultTypeInternal() {}
  union {
    InitConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitConfigDefaultTypeInternal _InitConfig_default_instance_;
bool InitConfig_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InitConfig_Mode_strings[2] = {};

static const char InitConfig_Mode_names[] =
  "RECEIVER"
  "SENDER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InitConfig_Mode_entries[] = {
  { {InitConfig_Mode_names + 0, 8}, 1 },
  { {InitConfig_Mode_names + 8, 6}, 0 },
};

static const int InitConfig_Mode_entries_by_number[] = {
  1, // 0 -> SENDER
  0, // 1 -> RECEIVER
};

const std::string& InitConfig_Mode_Name(
    InitConfig_Mode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InitConfig_Mode_entries,
          InitConfig_Mode_entries_by_number,
          2, InitConfig_Mode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InitConfig_Mode_entries,
      InitConfig_Mode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InitConfig_Mode_strings[idx].get();
}
bool InitConfig_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InitConfig_Mode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InitConfig_Mode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<InitConfig_Mode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr InitConfig_Mode InitConfig::SENDER;
constexpr InitConfig_Mode InitConfig::RECEIVER;
constexpr InitConfig_Mode InitConfig::Mode_MIN;
constexpr InitConfig_Mode InitConfig::Mode_MAX;
constexpr int InitConfig::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class InitConfig_Endpoint::_Internal {
 public:
};

InitConfig_Endpoint::InitConfig_Endpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitConfig.Endpoint)
}
InitConfig_Endpoint::InitConfig_Endpoint(const InitConfig_Endpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_addr().empty()) {
    addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_addr(), 
      GetArenaForAllocation());
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:InitConfig.Endpoint)
}

inline void InitConfig_Endpoint::SharedCtor() {
addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_ = 0;
}

InitConfig_Endpoint::~InitConfig_Endpoint() {
  // @@protoc_insertion_point(destructor:InitConfig.Endpoint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitConfig_Endpoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  addr_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void InitConfig_Endpoint::ArenaDtor(void* object) {
  InitConfig_Endpoint* _this = reinterpret_cast< InitConfig_Endpoint* >(object);
  (void)_this;
}
void InitConfig_Endpoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitConfig_Endpoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitConfig_Endpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:InitConfig.Endpoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  addr_.ClearToEmpty();
  port_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* InitConfig_Endpoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes addr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_addr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitConfig_Endpoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitConfig.Endpoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes addr = 1;
  if (!this->_internal_addr().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_addr(), target);
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitConfig.Endpoint)
  return target;
}

size_t InitConfig_Endpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitConfig.Endpoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes addr = 1;
  if (!this->_internal_addr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_addr());
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitConfig_Endpoint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitConfig_Endpoint*>(
      &from));
}

void InitConfig_Endpoint::MergeFrom(const InitConfig_Endpoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitConfig.Endpoint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_addr().empty()) {
    _internal_set_addr(from._internal_addr());
  }
  if (from._internal_port() != 0) {
    _internal_set_port(from._internal_port());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitConfig_Endpoint::CopyFrom(const InitConfig_Endpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitConfig.Endpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitConfig_Endpoint::IsInitialized() const {
  return true;
}

void InitConfig_Endpoint::InternalSwap(InitConfig_Endpoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &addr_, lhs_arena,
      &other->addr_, rhs_arena
  );
  swap(port_, other->port_);
}

std::string InitConfig_Endpoint::GetTypeName() const {
  return "InitConfig.Endpoint";
}


// ===================================================================

class InitConfig_Mux::_Internal {
 public:
};

InitConfig_Mux::InitConfig_Mux(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitConfig.Mux)
}
InitConfig_Mux::InitConfig_Mux(const InitConfig_Mux& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&maxchannels_, &from.maxchannels_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxpacketsize_) -
    reinterpret_cast<char*>(&maxchannels_)) + sizeof(maxpacketsize_));
  // @@protoc_insertion_point(copy_constructor:InitConfig.Mux)
}

inline void InitConfig_Mux::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&maxchannels_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxpacketsize_) -
    reinterpret_cast<char*>(&maxchannels_)) + sizeof(maxpacketsize_));
}

InitConfig_Mux::~InitConfig_Mux() {
  // @@protoc_insertion_point(destructor:InitConfig.Mux)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitConfig_Mux::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InitConfig_Mux::ArenaDtor(void* object) {
  InitConfig_Mux* _this = reinterpret_cast< InitConfig_Mux* >(object);
  (void)_this;
}
void InitConfig_Mux::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitConfig_Mux::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitConfig_Mux::Clear() {
// @@protoc_insertion_point(message_clear_start:InitConfig.Mux)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&maxchannels_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxpacketsize_) -
      reinterpret_cast<char*>(&maxchannels_)) + sizeof(maxpacketsize_));
  _internal_metadata_.Clear<std::string>();
}

const char* InitConfig_Mux::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 maxChannels = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          maxchannels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 maxPacketSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          maxpacketsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitConfig_Mux::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitConfig.Mux)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 maxChannels = 1;
  if (this->_internal_maxchannels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_maxchannels(), target);
  }

  // int32 maxPacketSize = 2;
  if (this->_internal_maxpacketsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_maxpacketsize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitConfig.Mux)
  return target;
}

size_t InitConfig_Mux::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitConfig.Mux)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 maxChannels = 1;
  if (this->_internal_maxchannels() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_maxchannels());
  }

  // int32 maxPacketSize = 2;
  if (this->_internal_maxpacketsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_maxpacketsize());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitConfig_Mux::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitConfig_Mux*>(
      &from));
}

void InitConfig_Mux::MergeFrom(const InitConfig_Mux& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitConfig.Mux)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_maxchannels() != 0) {
    _internal_set_maxchannels(from._internal_maxchannels());
  }
  if (from._internal_maxpacketsize() != 0) {
    _internal_set_maxpacketsize(from._internal_maxpacketsize());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitConfig_Mux::CopyFrom(const InitConfig_Mux& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitConfig.Mux)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitConfig_Mux::IsInitialized() const {
  return true;
}

void InitConfig_Mux::InternalSwap(InitConfig_Mux* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitConfig_Mux, maxpacketsize_)
      + sizeof(InitConfig_Mux::maxpacketsize_)
      - PROTOBUF_FIELD_OFFSET(InitConfig_Mux, maxchannels_)>(
          reinterpret_cast<char*>(&maxchannels_),
          reinterpret_cast<char*>(&other->maxchannels_));
}

std::string InitConfig_Mux::GetTypeName() const {
  return "InitConfig.Mux";
}


// ===================================================================

class InitConfig_Audio::_Internal {
 public:
};

InitConfig_Audio::InitConfig_Audio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitConfig.Audio)
}
InitConfig_Audio::InitConfig_Audio(const InitConfig_Audio& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  devicename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    devicename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_devicename().empty()) {
    devicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_devicename(), 
      GetArenaForAllocation());
  }
  ::memcpy(&channelcount_, &from.channelcount_,
    static_cast<size_t>(reinterpret_cast<char*>(&levelfastrelease_) -
    reinterpret_cast<char*>(&channelcount_)) + sizeof(levelfastrelease_));
  // @@protoc_insertion_point(copy_constructor:InitConfig.Audio)
}

inline void InitConfig_Audio::SharedCtor() {
devicename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  devicename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&channelcount_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&levelfastrelease_) -
    reinterpret_cast<char*>(&channelcount_)) + sizeof(levelfastrelease_));
}

InitConfig_Audio::~InitConfig_Audio() {
  // @@protoc_insertion_point(destructor:InitConfig.Audio)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitConfig_Audio::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  devicename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void InitConfig_Audio::ArenaDtor(void* object) {
  InitConfig_Audio* _this = reinterpret_cast< InitConfig_Audio* >(object);
  (void)_this;
}
void InitConfig_Audio::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitConfig_Audio::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitConfig_Audio::Clear() {
// @@protoc_insertion_point(message_clear_start:InitConfig.Audio)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  devicename_.ClearToEmpty();
  ::memset(&channelcount_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&levelfastrelease_) -
      reinterpret_cast<char*>(&channelcount_)) + sizeof(levelfastrelease_));
  _internal_metadata_.Clear<std::string>();
}

const char* InitConfig_Audio::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 channelCount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          channelcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 ioSampleRate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          iosamplerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string deviceName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_devicename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float levelSlowAttack = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          levelslowattack_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float levelSlowRelease = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          levelslowrelease_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float levelFastAttack = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          levelfastattack_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float levelFastRelease = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          levelfastrelease_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitConfig_Audio::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitConfig.Audio)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 channelCount = 1;
  if (this->_internal_channelcount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_channelcount(), target);
  }

  // int32 ioSampleRate = 2;
  if (this->_internal_iosamplerate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_iosamplerate(), target);
  }

  // string deviceName = 3;
  if (!this->_internal_devicename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_devicename().data(), static_cast<int>(this->_internal_devicename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "InitConfig.Audio.deviceName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_devicename(), target);
  }

  // float levelSlowAttack = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelslowattack = this->_internal_levelslowattack();
  uint32_t raw_levelslowattack;
  memcpy(&raw_levelslowattack, &tmp_levelslowattack, sizeof(tmp_levelslowattack));
  if (raw_levelslowattack != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_levelslowattack(), target);
  }

  // float levelSlowRelease = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelslowrelease = this->_internal_levelslowrelease();
  uint32_t raw_levelslowrelease;
  memcpy(&raw_levelslowrelease, &tmp_levelslowrelease, sizeof(tmp_levelslowrelease));
  if (raw_levelslowrelease != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_levelslowrelease(), target);
  }

  // float levelFastAttack = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelfastattack = this->_internal_levelfastattack();
  uint32_t raw_levelfastattack;
  memcpy(&raw_levelfastattack, &tmp_levelfastattack, sizeof(tmp_levelfastattack));
  if (raw_levelfastattack != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_levelfastattack(), target);
  }

  // float levelFastRelease = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelfastrelease = this->_internal_levelfastrelease();
  uint32_t raw_levelfastrelease;
  memcpy(&raw_levelfastrelease, &tmp_levelfastrelease, sizeof(tmp_levelfastrelease));
  if (raw_levelfastrelease != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_levelfastrelease(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitConfig.Audio)
  return target;
}

size_t InitConfig_Audio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitConfig.Audio)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string deviceName = 3;
  if (!this->_internal_devicename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_devicename());
  }

  // int32 channelCount = 1;
  if (this->_internal_channelcount() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_channelcount());
  }

  // int32 ioSampleRate = 2;
  if (this->_internal_iosamplerate() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_iosamplerate());
  }

  // float levelSlowAttack = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelslowattack = this->_internal_levelslowattack();
  uint32_t raw_levelslowattack;
  memcpy(&raw_levelslowattack, &tmp_levelslowattack, sizeof(tmp_levelslowattack));
  if (raw_levelslowattack != 0) {
    total_size += 1 + 4;
  }

  // float levelSlowRelease = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelslowrelease = this->_internal_levelslowrelease();
  uint32_t raw_levelslowrelease;
  memcpy(&raw_levelslowrelease, &tmp_levelslowrelease, sizeof(tmp_levelslowrelease));
  if (raw_levelslowrelease != 0) {
    total_size += 1 + 4;
  }

  // float levelFastAttack = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelfastattack = this->_internal_levelfastattack();
  uint32_t raw_levelfastattack;
  memcpy(&raw_levelfastattack, &tmp_levelfastattack, sizeof(tmp_levelfastattack));
  if (raw_levelfastattack != 0) {
    total_size += 1 + 4;
  }

  // float levelFastRelease = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelfastrelease = this->_internal_levelfastrelease();
  uint32_t raw_levelfastrelease;
  memcpy(&raw_levelfastrelease, &tmp_levelfastrelease, sizeof(tmp_levelfastrelease));
  if (raw_levelfastrelease != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitConfig_Audio::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitConfig_Audio*>(
      &from));
}

void InitConfig_Audio::MergeFrom(const InitConfig_Audio& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitConfig.Audio)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_devicename().empty()) {
    _internal_set_devicename(from._internal_devicename());
  }
  if (from._internal_channelcount() != 0) {
    _internal_set_channelcount(from._internal_channelcount());
  }
  if (from._internal_iosamplerate() != 0) {
    _internal_set_iosamplerate(from._internal_iosamplerate());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelslowattack = from._internal_levelslowattack();
  uint32_t raw_levelslowattack;
  memcpy(&raw_levelslowattack, &tmp_levelslowattack, sizeof(tmp_levelslowattack));
  if (raw_levelslowattack != 0) {
    _internal_set_levelslowattack(from._internal_levelslowattack());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelslowrelease = from._internal_levelslowrelease();
  uint32_t raw_levelslowrelease;
  memcpy(&raw_levelslowrelease, &tmp_levelslowrelease, sizeof(tmp_levelslowrelease));
  if (raw_levelslowrelease != 0) {
    _internal_set_levelslowrelease(from._internal_levelslowrelease());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelfastattack = from._internal_levelfastattack();
  uint32_t raw_levelfastattack;
  memcpy(&raw_levelfastattack, &tmp_levelfastattack, sizeof(tmp_levelfastattack));
  if (raw_levelfastattack != 0) {
    _internal_set_levelfastattack(from._internal_levelfastattack());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_levelfastrelease = from._internal_levelfastrelease();
  uint32_t raw_levelfastrelease;
  memcpy(&raw_levelfastrelease, &tmp_levelfastrelease, sizeof(tmp_levelfastrelease));
  if (raw_levelfastrelease != 0) {
    _internal_set_levelfastrelease(from._internal_levelfastrelease());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitConfig_Audio::CopyFrom(const InitConfig_Audio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitConfig.Audio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitConfig_Audio::IsInitialized() const {
  return true;
}

void InitConfig_Audio::InternalSwap(InitConfig_Audio* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &devicename_, lhs_arena,
      &other->devicename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitConfig_Audio, levelfastrelease_)
      + sizeof(InitConfig_Audio::levelfastrelease_)
      - PROTOBUF_FIELD_OFFSET(InitConfig_Audio, channelcount_)>(
          reinterpret_cast<char*>(&channelcount_),
          reinterpret_cast<char*>(&other->channelcount_));
}

std::string InitConfig_Audio::GetTypeName() const {
  return "InitConfig.Audio";
}


// ===================================================================

class InitConfig_Opus::_Internal {
 public:
};

InitConfig_Opus::InitConfig_Opus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitConfig.Opus)
}
InitConfig_Opus::InitConfig_Opus(const InitConfig_Opus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&bitrate_, &from.bitrate_,
    static_cast<size_t>(reinterpret_cast<char*>(&decoderinglength_) -
    reinterpret_cast<char*>(&bitrate_)) + sizeof(decoderinglength_));
  // @@protoc_insertion_point(copy_constructor:InitConfig.Opus)
}

inline void InitConfig_Opus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bitrate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&decoderinglength_) -
    reinterpret_cast<char*>(&bitrate_)) + sizeof(decoderinglength_));
}

InitConfig_Opus::~InitConfig_Opus() {
  // @@protoc_insertion_point(destructor:InitConfig.Opus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitConfig_Opus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InitConfig_Opus::ArenaDtor(void* object) {
  InitConfig_Opus* _this = reinterpret_cast< InitConfig_Opus* >(object);
  (void)_this;
}
void InitConfig_Opus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitConfig_Opus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitConfig_Opus::Clear() {
// @@protoc_insertion_point(message_clear_start:InitConfig.Opus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&bitrate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&decoderinglength_) -
      reinterpret_cast<char*>(&bitrate_)) + sizeof(decoderinglength_));
  _internal_metadata_.Clear<std::string>();
}

const char* InitConfig_Opus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 bitrate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 frameSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          framesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 maxPacketSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          maxpacketsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sampleRate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          samplerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 encodeRingLength = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          encoderinglength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 decodeRingLength = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          decoderinglength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitConfig_Opus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitConfig.Opus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 bitrate = 1;
  if (this->_internal_bitrate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_bitrate(), target);
  }

  // int32 frameSize = 2;
  if (this->_internal_framesize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_framesize(), target);
  }

  // int32 maxPacketSize = 3;
  if (this->_internal_maxpacketsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_maxpacketsize(), target);
  }

  // int32 sampleRate = 4;
  if (this->_internal_samplerate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_samplerate(), target);
  }

  // int32 encodeRingLength = 5;
  if (this->_internal_encoderinglength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_encoderinglength(), target);
  }

  // int32 decodeRingLength = 6;
  if (this->_internal_decoderinglength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_decoderinglength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitConfig.Opus)
  return target;
}

size_t InitConfig_Opus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitConfig.Opus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 bitrate = 1;
  if (this->_internal_bitrate() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_bitrate());
  }

  // int32 frameSize = 2;
  if (this->_internal_framesize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_framesize());
  }

  // int32 maxPacketSize = 3;
  if (this->_internal_maxpacketsize() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_maxpacketsize());
  }

  // int32 sampleRate = 4;
  if (this->_internal_samplerate() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_samplerate());
  }

  // int32 encodeRingLength = 5;
  if (this->_internal_encoderinglength() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_encoderinglength());
  }

  // int32 decodeRingLength = 6;
  if (this->_internal_decoderinglength() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_decoderinglength());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitConfig_Opus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitConfig_Opus*>(
      &from));
}

void InitConfig_Opus::MergeFrom(const InitConfig_Opus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitConfig.Opus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_bitrate() != 0) {
    _internal_set_bitrate(from._internal_bitrate());
  }
  if (from._internal_framesize() != 0) {
    _internal_set_framesize(from._internal_framesize());
  }
  if (from._internal_maxpacketsize() != 0) {
    _internal_set_maxpacketsize(from._internal_maxpacketsize());
  }
  if (from._internal_samplerate() != 0) {
    _internal_set_samplerate(from._internal_samplerate());
  }
  if (from._internal_encoderinglength() != 0) {
    _internal_set_encoderinglength(from._internal_encoderinglength());
  }
  if (from._internal_decoderinglength() != 0) {
    _internal_set_decoderinglength(from._internal_decoderinglength());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitConfig_Opus::CopyFrom(const InitConfig_Opus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitConfig.Opus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitConfig_Opus::IsInitialized() const {
  return true;
}

void InitConfig_Opus::InternalSwap(InitConfig_Opus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitConfig_Opus, decoderinglength_)
      + sizeof(InitConfig_Opus::decoderinglength_)
      - PROTOBUF_FIELD_OFFSET(InitConfig_Opus, bitrate_)>(
          reinterpret_cast<char*>(&bitrate_),
          reinterpret_cast<char*>(&other->bitrate_));
}

std::string InitConfig_Opus::GetTypeName() const {
  return "InitConfig.Opus";
}


// ===================================================================

class InitConfig_Fec::_Internal {
 public:
};

InitConfig_Fec::InitConfig_Fec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitConfig.Fec)
}
InitConfig_Fec::InitConfig_Fec(const InitConfig_Fec& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&symbollen_, &from.symbollen_,
    static_cast<size_t>(reinterpret_cast<char*>(&repairsymbolsperblock_) -
    reinterpret_cast<char*>(&symbollen_)) + sizeof(repairsymbolsperblock_));
  // @@protoc_insertion_point(copy_constructor:InitConfig.Fec)
}

inline void InitConfig_Fec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&symbollen_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&repairsymbolsperblock_) -
    reinterpret_cast<char*>(&symbollen_)) + sizeof(repairsymbolsperblock_));
}

InitConfig_Fec::~InitConfig_Fec() {
  // @@protoc_insertion_point(destructor:InitConfig.Fec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitConfig_Fec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InitConfig_Fec::ArenaDtor(void* object) {
  InitConfig_Fec* _this = reinterpret_cast< InitConfig_Fec* >(object);
  (void)_this;
}
void InitConfig_Fec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitConfig_Fec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitConfig_Fec::Clear() {
// @@protoc_insertion_point(message_clear_start:InitConfig.Fec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&symbollen_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&repairsymbolsperblock_) -
      reinterpret_cast<char*>(&symbollen_)) + sizeof(repairsymbolsperblock_));
  _internal_metadata_.Clear<std::string>();
}

const char* InitConfig_Fec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 symbolLen = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          symbollen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sourceSymbolsPerBlock = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          sourcesymbolsperblock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 repairSymbolsPerBlock = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          repairsymbolsperblock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitConfig_Fec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitConfig.Fec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 symbolLen = 1;
  if (this->_internal_symbollen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_symbollen(), target);
  }

  // int32 sourceSymbolsPerBlock = 2;
  if (this->_internal_sourcesymbolsperblock() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_sourcesymbolsperblock(), target);
  }

  // int32 repairSymbolsPerBlock = 3;
  if (this->_internal_repairsymbolsperblock() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_repairsymbolsperblock(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitConfig.Fec)
  return target;
}

size_t InitConfig_Fec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitConfig.Fec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 symbolLen = 1;
  if (this->_internal_symbollen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_symbollen());
  }

  // int32 sourceSymbolsPerBlock = 2;
  if (this->_internal_sourcesymbolsperblock() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sourcesymbolsperblock());
  }

  // int32 repairSymbolsPerBlock = 3;
  if (this->_internal_repairsymbolsperblock() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_repairsymbolsperblock());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitConfig_Fec::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitConfig_Fec*>(
      &from));
}

void InitConfig_Fec::MergeFrom(const InitConfig_Fec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitConfig.Fec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_symbollen() != 0) {
    _internal_set_symbollen(from._internal_symbollen());
  }
  if (from._internal_sourcesymbolsperblock() != 0) {
    _internal_set_sourcesymbolsperblock(from._internal_sourcesymbolsperblock());
  }
  if (from._internal_repairsymbolsperblock() != 0) {
    _internal_set_repairsymbolsperblock(from._internal_repairsymbolsperblock());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitConfig_Fec::CopyFrom(const InitConfig_Fec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitConfig.Fec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitConfig_Fec::IsInitialized() const {
  return true;
}

void InitConfig_Fec::InternalSwap(InitConfig_Fec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitConfig_Fec, repairsymbolsperblock_)
      + sizeof(InitConfig_Fec::repairsymbolsperblock_)
      - PROTOBUF_FIELD_OFFSET(InitConfig_Fec, symbollen_)>(
          reinterpret_cast<char*>(&symbollen_),
          reinterpret_cast<char*>(&other->symbollen_));
}

std::string InitConfig_Fec::GetTypeName() const {
  return "InitConfig.Fec";
}


// ===================================================================

class InitConfig_Monitor::_Internal {
 public:
};

InitConfig_Monitor::InitConfig_Monitor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitConfig.Monitor)
}
InitConfig_Monitor::InitConfig_Monitor(const InitConfig_Monitor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  wsport_ = from.wsport_;
  // @@protoc_insertion_point(copy_constructor:InitConfig.Monitor)
}

inline void InitConfig_Monitor::SharedCtor() {
wsport_ = 0;
}

InitConfig_Monitor::~InitConfig_Monitor() {
  // @@protoc_insertion_point(destructor:InitConfig.Monitor)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitConfig_Monitor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InitConfig_Monitor::ArenaDtor(void* object) {
  InitConfig_Monitor* _this = reinterpret_cast< InitConfig_Monitor* >(object);
  (void)_this;
}
void InitConfig_Monitor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitConfig_Monitor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitConfig_Monitor::Clear() {
// @@protoc_insertion_point(message_clear_start:InitConfig.Monitor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  wsport_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* InitConfig_Monitor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 wsPort = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          wsport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitConfig_Monitor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitConfig.Monitor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 wsPort = 1;
  if (this->_internal_wsport() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_wsport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitConfig.Monitor)
  return target;
}

size_t InitConfig_Monitor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitConfig.Monitor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 wsPort = 1;
  if (this->_internal_wsport() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_wsport());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitConfig_Monitor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitConfig_Monitor*>(
      &from));
}

void InitConfig_Monitor::MergeFrom(const InitConfig_Monitor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitConfig.Monitor)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_wsport() != 0) {
    _internal_set_wsport(from._internal_wsport());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitConfig_Monitor::CopyFrom(const InitConfig_Monitor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitConfig.Monitor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitConfig_Monitor::IsInitialized() const {
  return true;
}

void InitConfig_Monitor::InternalSwap(InitConfig_Monitor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(wsport_, other->wsport_);
}

std::string InitConfig_Monitor::GetTypeName() const {
  return "InitConfig.Monitor";
}


// ===================================================================

class InitConfig::_Internal {
 public:
  static const ::InitConfig_Mux& mux(const InitConfig* msg);
  static const ::InitConfig_Audio& audio(const InitConfig* msg);
  static const ::InitConfig_Opus& opus(const InitConfig* msg);
  static const ::InitConfig_Fec& fec(const InitConfig* msg);
  static const ::InitConfig_Monitor& monitor(const InitConfig* msg);
};

const ::InitConfig_Mux&
InitConfig::_Internal::mux(const InitConfig* msg) {
  return *msg->mux_;
}
const ::InitConfig_Audio&
InitConfig::_Internal::audio(const InitConfig* msg) {
  return *msg->audio_;
}
const ::InitConfig_Opus&
InitConfig::_Internal::opus(const InitConfig* msg) {
  return *msg->opus_;
}
const ::InitConfig_Fec&
InitConfig::_Internal::fec(const InitConfig* msg) {
  return *msg->fec_;
}
const ::InitConfig_Monitor&
InitConfig::_Internal::monitor(const InitConfig* msg) {
  return *msg->monitor_;
}
InitConfig::InitConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  endpoints_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:InitConfig)
}
InitConfig::InitConfig(const InitConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      endpoints_(from.endpoints_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_mux()) {
    mux_ = new ::InitConfig_Mux(*from.mux_);
  } else {
    mux_ = nullptr;
  }
  if (from._internal_has_audio()) {
    audio_ = new ::InitConfig_Audio(*from.audio_);
  } else {
    audio_ = nullptr;
  }
  if (from._internal_has_opus()) {
    opus_ = new ::InitConfig_Opus(*from.opus_);
  } else {
    opus_ = nullptr;
  }
  if (from._internal_has_fec()) {
    fec_ = new ::InitConfig_Fec(*from.fec_);
  } else {
    fec_ = nullptr;
  }
  if (from._internal_has_monitor()) {
    monitor_ = new ::InitConfig_Monitor(*from.monitor_);
  } else {
    monitor_ = nullptr;
  }
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:InitConfig)
}

inline void InitConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mux_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&mux_)) + sizeof(mode_));
}

InitConfig::~InitConfig() {
  // @@protoc_insertion_point(destructor:InitConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void InitConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete mux_;
  if (this != internal_default_instance()) delete audio_;
  if (this != internal_default_instance()) delete opus_;
  if (this != internal_default_instance()) delete fec_;
  if (this != internal_default_instance()) delete monitor_;
}

void InitConfig::ArenaDtor(void* object) {
  InitConfig* _this = reinterpret_cast< InitConfig* >(object);
  (void)_this;
}
void InitConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:InitConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  endpoints_.Clear();
  if (GetArenaForAllocation() == nullptr && mux_ != nullptr) {
    delete mux_;
  }
  mux_ = nullptr;
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
  if (GetArenaForAllocation() == nullptr && opus_ != nullptr) {
    delete opus_;
  }
  opus_ = nullptr;
  if (GetArenaForAllocation() == nullptr && fec_ != nullptr) {
    delete fec_;
  }
  fec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && monitor_ != nullptr) {
    delete monitor_;
  }
  monitor_ = nullptr;
  mode_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* InitConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .InitConfig.Mode mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::InitConfig_Mode>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .InitConfig.Endpoint endpoints = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_endpoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .InitConfig.Mux mux = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_mux(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .InitConfig.Audio audio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .InitConfig.Opus opus = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_opus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .InitConfig.Fec fec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_fec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .InitConfig.Monitor monitor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_monitor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InitConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .InitConfig.Mode mode = 1;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  // repeated .InitConfig.Endpoint endpoints = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_endpoints_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_endpoints(i), target, stream);
  }

  // .InitConfig.Mux mux = 3;
  if (this->_internal_has_mux()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::mux(this), target, stream);
  }

  // .InitConfig.Audio audio = 4;
  if (this->_internal_has_audio()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::audio(this), target, stream);
  }

  // .InitConfig.Opus opus = 5;
  if (this->_internal_has_opus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::opus(this), target, stream);
  }

  // .InitConfig.Fec fec = 6;
  if (this->_internal_has_fec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::fec(this), target, stream);
  }

  // .InitConfig.Monitor monitor = 7;
  if (this->_internal_has_monitor()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::monitor(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InitConfig)
  return target;
}

size_t InitConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InitConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .InitConfig.Endpoint endpoints = 2;
  total_size += 1UL * this->_internal_endpoints_size();
  for (const auto& msg : this->endpoints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .InitConfig.Mux mux = 3;
  if (this->_internal_has_mux()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *mux_);
  }

  // .InitConfig.Audio audio = 4;
  if (this->_internal_has_audio()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *audio_);
  }

  // .InitConfig.Opus opus = 5;
  if (this->_internal_has_opus()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *opus_);
  }

  // .InitConfig.Fec fec = 6;
  if (this->_internal_has_fec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fec_);
  }

  // .InitConfig.Monitor monitor = 7;
  if (this->_internal_has_monitor()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *monitor_);
  }

  // .InitConfig.Mode mode = 1;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const InitConfig*>(
      &from));
}

void InitConfig::MergeFrom(const InitConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:InitConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  endpoints_.MergeFrom(from.endpoints_);
  if (from._internal_has_mux()) {
    _internal_mutable_mux()->::InitConfig_Mux::MergeFrom(from._internal_mux());
  }
  if (from._internal_has_audio()) {
    _internal_mutable_audio()->::InitConfig_Audio::MergeFrom(from._internal_audio());
  }
  if (from._internal_has_opus()) {
    _internal_mutable_opus()->::InitConfig_Opus::MergeFrom(from._internal_opus());
  }
  if (from._internal_has_fec()) {
    _internal_mutable_fec()->::InitConfig_Fec::MergeFrom(from._internal_fec());
  }
  if (from._internal_has_monitor()) {
    _internal_mutable_monitor()->::InitConfig_Monitor::MergeFrom(from._internal_monitor());
  }
  if (from._internal_mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitConfig::CopyFrom(const InitConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InitConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitConfig::IsInitialized() const {
  return true;
}

void InitConfig::InternalSwap(InitConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  endpoints_.InternalSwap(&other->endpoints_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitConfig, mode_)
      + sizeof(InitConfig::mode_)
      - PROTOBUF_FIELD_OFFSET(InitConfig, mux_)>(
          reinterpret_cast<char*>(&mux_),
          reinterpret_cast<char*>(&other->mux_));
}

std::string InitConfig::GetTypeName() const {
  return "InitConfig";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::InitConfig_Endpoint* Arena::CreateMaybeMessage< ::InitConfig_Endpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitConfig_Endpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::InitConfig_Mux* Arena::CreateMaybeMessage< ::InitConfig_Mux >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitConfig_Mux >(arena);
}
template<> PROTOBUF_NOINLINE ::InitConfig_Audio* Arena::CreateMaybeMessage< ::InitConfig_Audio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitConfig_Audio >(arena);
}
template<> PROTOBUF_NOINLINE ::InitConfig_Opus* Arena::CreateMaybeMessage< ::InitConfig_Opus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitConfig_Opus >(arena);
}
template<> PROTOBUF_NOINLINE ::InitConfig_Fec* Arena::CreateMaybeMessage< ::InitConfig_Fec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitConfig_Fec >(arena);
}
template<> PROTOBUF_NOINLINE ::InitConfig_Monitor* Arena::CreateMaybeMessage< ::InitConfig_Monitor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitConfig_Monitor >(arena);
}
template<> PROTOBUF_NOINLINE ::InitConfig* Arena::CreateMaybeMessage< ::InitConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InitConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
